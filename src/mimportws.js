import chalk from 'chalk'
//
import { ellipse, getEndpoint, readFile, readJson } from './util'

// Plugin boilerplate
export const command = 'mimportws file'
export const desc = 'Import a workspace'
export const builder = {
  file: {
    description: 'Workspace file (generated by mexportws command)'
  },
  userId: {
    alias: 'u',
    description: 'Optional userId to import workspace under'
  },
  endpoint: {
    alias: 'e',
    description: 'Optional endpoint to use'
  }
}

const KindFieldsFragment = `
  fragment kindFields on Kind {
    id
    name
    serviceId
    description
    thumbnailUrl
    isPublic
    isManaged
    isSystem
    schema {
      id
      name
      type
      description
      modifiers
      typeKindId
      displayAs
      hide
      autoFocus
      readonly
    }
    nameField
  }
`

export const handler = async (context, argv) => {
  // console.log("context", context);
  // console.log("argv", argv);

  const config = await context.getProjectConfig()
  // console.log("config", config);

  const configPath = config.configPath

  const extensions = config.extensions || {}
  // console.log("extensions", extensions);

  const options = extensions.maana || {}
  // console.log("options", options);

  const endpoint = getEndpoint(config, argv)
  if (!endpoint) return
  context['client'] = endpoint.getClient()

  if (!argv.file) {
    console.log(
      chalk.red(`âœ˜ Must specify a file to import (from previous export)`)
    )
    return
  }

  context.spinner.start(chalk.yellow(`Loading workspace data`))
  const data = readJson(argv.file)

  try {
    // User
    let userId = argv.userId || undefined
    if (!userId) {
      const existingUsers = await getExistingUsers(context)
      userId = await ensureUser(existingUsers, data.owner)
    }

    // Services
    const existingServices = await getExistingServices(context)
    const indexedServices = indexServices(existingServices)
    context['serviceDetails'] = await ensureServices(
      context,
      indexedServices,
      data.services
    )

    // Workspace
    context['workspaceId'] = await addWorkspace(context, userId, data)
    context['kindMap'] = await addWorkspaceKinds(
      context,
      data.inventory.workspaceKinds
    )
    context['functionMap'] = await addFunctions(
      context,
      data.inventory.functions
    )
    await addPortalGraphs(context, data.portalGraphs)
  } catch (errors) {
    context.spinner.fail(chalk.red(`Call failed! ${JSON.stringify(errors)}`))
    return
  }
  context.spinner.succeed(chalk.green(`Import succeeded`))
}

const getExistingUsers = async context => {
  context.spinner.start(chalk.yellow(`Getting existing users`))
  const query = `
    query {
      allUsers {
        id
        name
        givenName
        familyName
        email
        picture
        theme
      }
    }
  `
  const result = await request(context, query)
  return result.allUsers
}

const ensureUser = async (existingUsers, owner) => {
  for (let i = 0; i < existingUsers.length; i++) {
    const x = existingUsers[i]
    if (x.id === owner.id || x.email === owner.email) return x.id
  }
  throw 'No existing user and no target user specified.'
}

const addWorkspace = async (context, userId, ws) => {
  context.spinner.start(chalk.yellow(`Adding workspace`))
  const query = `
    mutation addWorkspace($input: AddWorkspaceInput!) {
      addWorkspace(input: $input)
    }`
  const input = {
    userId: userId,
    name: ws.name,
    thumbnailUrl: ws.thumbnailUrl
  }
  const result = await request(context, query, { input })
  return result.addWorkspace
}

const getExistingServices = async context => {
  context.spinner.start(chalk.yellow(`Getting existing services`))
  const query = `
    query allServices {
      allServices {
        id
        name
        endpointUrl
      }
    }
`
  const result = await request(context, query)
  return result.allServices
}

const indexServices = services => {
  const index = {}
  services.forEach(x => (index[x.endpointUrl] = x))
  return index
}

const ensureServices = async (context, indexedServices, services) => {
  context.spinner.start(chalk.yellow(`Ensuring services`))
  const serviceDetails = {}
  for (let i = 0; i < services.length; i++) {
    const svc = services[i]
    let targetSvcId
    const existingSvc = indexedServices[svc.endpointUrl]
    if (!existingSvc) {
      context.spinner.start(chalk.yellow(`Adding service:`, svc.name))
      targetSvcId = await addService(context, svc)
    } else {
      targetSvcId = existingSvc.id
    }
    context.spinner.start(chalk.yellow(`Getting service details:`, svc.name))
    serviceDetails[svc.id] = await getServiceDetails(context, targetSvcId)
  }
  return serviceDetails
}

const addService = async (context, service) => {
  const query = `
    mutation addService($input: AddServiceInput!) {
      addService(input: $input)
    }
  `

  // Only write what schema requires
  const input = {
    id: service.id,
    name: service.name,
    isSystem: service.isSystem,
    isReadOnly: service.isReadOnly,
    thumbnailUrl: service.thumbnailUrl,
    endpointUrl: service.endpointUrl,
    subscriptionEndpointUrl: service.subscriptionEndpointUrl,
    tags: service.tags,
    schema: service.schema
  }
  const result = await request(context, query, { input })
  return result.addService
}

const getServiceDetails = async (context, id) => {
  const query = `
    query service($id: ID!) {
      service(id: $id) {
        id
        name
        kinds {
          id
          name
        }
        functions {
          id
          name
        }
      }
    }
  `
  const result = await request(context, query, { id })
  return result.service
}

const addWorkspaceKinds = async (context, workspaceKinds) => {
  context.spinner.start(chalk.yellow(`Adding workspace kinds`))

  const kindMap = {}
  for (let i = 0; i < workspaceKinds.length; i++) {
    const wsKind = workspaceKinds[i]
    const newId = await addKind(context, wsKind)
    kindMap[wsKind.id] = newId
  }
  return kindMap
}

const addKind = async (context, kind) => {
  // Check for existing and remap
  const svcDetails = context.serviceDetails[kind.serviceId]
  if (svcDetails) {
    for (let i = 0; i < svcDetails.kinds.length; i++) {
      const svcKind = svcDetails.kinds[i]
      if (svcKind.name === kind.name) return svcKind.id
    }
    throw `Service Kind not found in target definition: ${svcDetails.name}:${kind.name}`
  }

  const query = `
    mutation addKind($input: AddKindInput!) {
      addKind(tenantId: 0, input: $input)
    }`

  try {
    const result = await request(context, query, { input: kind })
    return result.addKind
  } catch (error) {
    console.log('error', error)
    return kind.id
  }
}

const addFunctions = async (context, functions) => {
  context.spinner.start(chalk.yellow(`Adding functions`))
  const functionMap = {}
  for (let i = 0; i < functions.length; i++) {
    const fn = functions[i]
    const newId = await addFunction(context, fn)
    functionMap[fn.id] = newId
  }
  console.log('fn map', functionMap)
  return functionMap
}

const addFunction = async (context, fn) => {
  // Check for existing and remap
  const svcDetails = context.serviceDetails[fn.service.id]
  if (svcDetails) {
    for (let i = 0; i < svcDetails.functions.length; i++) {
      const svcFn = svcDetails.functions[i]
      if (svcFn.name === fn.name) return svcFn.id
    }
    throw `Service Function not found in target definition: ${svcDetails.name}:${fn.name}`
  }

  const query = `
    mutation addFunction($input: FunctionInput!) {
      addFunction(input: $input)
    }`
  const kindMap = context.kindMap
  console.log('\n\n\nkind map\n\n', kindMap)
  const input = Object.assign({}, fn, {
    arguments: fn.arguments.map(x =>
      Object.assign({}, x, { typeKindId: kindMap[x.typeKindId] })
    ),
    outputKindId: kindMap[fn.outputKindId]
  })
  console.log('\naddFunction: ', input)
  // const result = await request(context, query, { input })
  // return result.addFunction
}

const addPortalGraphs = async (context, pgs) => {
  context.spinner.start(chalk.yellow(`Adding portal graphs`))
  const query = `
    mutation addPortalGraph($input: AddPortalGraphInput!) {
      addPortalGraph(input: $input) { id }
    }`

  const pgIds = []
  for (let i = 0; i < pgs.length; i++) {
    const pg = pgs[i]
    const nodes = pg.nodes.map(x => {
      const node = {
        id: x.id,
        x: x.x,
        y: x.y,
        width: x.width,
        height: x.height,
        collapsed: x.collapsed
      }
      if (x.knowledgeGraphNode) {
        node['knowledgeGraphNode'] = {
          id: x.knowledgeGraphNode.id,
          instanceId: x.knowledgeGraphNode.instance.id,
          kindName: x.knowledgeGraphNode.kind.name
        }
      } else if (x.functionGraphNode) {
        // node['functionGraphNode'] = x.functionGraphNode
        // NOTE: adding these explicitly is not supported by the platform
      } else {
      }
      return node
    })
    const input = {
      id: pg.id,
      workspaceId: context.workspaceId,
      type: pg.type,
      name: pg.name,
      nodes
    }
    // console.log('\naddPortalGraph: ', input)
    const result = await request(context, query, { input })
    pgIds.push(result.addPortalGraph.id)
  }
}

const request = async (context, query, variables) => {
  const result = await context.client.request(query, variables)
  if (result['errors']) throw result.errors
  return result
}
